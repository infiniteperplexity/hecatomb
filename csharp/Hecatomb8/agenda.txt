
cd C:\Users\infin\OneDrive\Documents\GitHub\hecatomb\csharp\Hecatomb8
gci . *.cs -Recurse | select-string . | Group Filename | Measure-Object Count -Sum -Min -Max -Average


So what would our approach be to refactoring the game?  Let's make this a wishlist.
- I think you basically just start by backing up Game.cs, start that again from scratch, and go from there.
- Let's take a look at this example code.  So, they've got a Global object.
- So what is it I'm actually looking to improve on here?
	- I want to take full advantage of the new null protections.
	- I want to totally shut down race conditions.
	- In my dreams, I log all game and interface events.
		- It's clear what a game event is.  An interface event is a little less clear.
	- I could try improve on some of the more intricate systems, like spawning, serializing, events, and so on.
	- I have some specific things I want to change, like getting rid of the JSON-loading text-key nonsnese.


4/14/2020

So we have the "minimal MCV" thing down now.  So what's next?
- We want to generate the world
- We want to implement the normal controls

4/18/2020

Things are kind of a little bit recognizable, in that we have a panel handling the drawing, the ability to run around on the surface, and glyphs that look kind of okay.
So what are some upcoming chunks of functionality to add?
- I think I want to start by - instead of adding fun stuff - set up the general "game" structure.
- Then work on the turn structure.
- I think we want to save Tasks and Components as long as possible.  Those are by far where the most screw-ups happen.  Hopefully that's where all the groundwork
I'm laying pays off.

4/19/2020

Okay, I schlepped for a bit.  I really actually kind of want to go outside.
Alright, what's next?  Let's toss some ideas out there...
 - Camera mode.
 - Get trees and graves up in there.
 - Cast spells to summon zombies.
 - Zombies wander around and pathfind.
 - Set up the "new game" framework.  Yeah...let's get that going.

 4/20/2020
 Alright, so I have time passing...but I think I may have noticed a weakness in the system...
 ...ready for input can be triggered by input, but it can also be triggered by time passing...is that a real issue?
 ...I think maybe not, because I doubt the update loops can overlap, and the time passing portion of the loop always completes before the input portion of the loop, right?


 4/23/2020
 - Particles are buggy in some weird way, but I bet I can fix that later.  Right now they work kinda, and I want to get Save and Restore Game imeplemented.
 - Alright, so in theory I've implemented saving and restoring games.  But we all know in practice when I run this, a bunch of stuff is going to go wrong.
    - First off, there will probably be at least a few straight-up crashes, some related to null references and others related to...well...Json null references.
    - Second, there definitely be serialization problems, were the state doesn't get serialized the way you'd hope it would.  In fact, I realized I totally don't parse Entities correctly; they need to pick class based on a field.
 - But I don't know that I want to tackle all that tonight.  It's already eight and there's a couple of other projects I'm thinking of tackling.
 - Lets talk about some other pockets of functionality:
    - Serialization.
    - Fleshing out the interface.
    - Tasks and Actors
    - Tutorial
    - Restoring content
    - Structures
- Maybe tonight let's try to hunt down the particles issue

4/26/2020
- Okay, so we've got a good portion of the interface stuff done.  Ummm....MessageHandler next?
- Alright, the tutorial and the messagehandler are working.
- I'm worried that we're double deducting action points for the player

4/27/2020
- So...we're going to need to reall go through the player action point stuff and make sure we do it right.  The main thing I'm worried about is that "step to"
is going to double-deduct action points
- Oof.  I can feel things building toward a breaking point here.

Okay...take a deep breath...let's talk about...shall we call it...the "cleanup problem."  The cleanup problem, briefly stated, is that when a game entity enters an invalid state - either just not on the map, or
more commonly, despawned - other objects might be clinging to a reference to it.  Then if they later try to use that reference, it might be unexpectedly null.  So, the current
way we do this is as follows:
- For some major purposes, we use the Event system.  But it's hard to catch all of these; that requires signing tons of things up for listeners, and if you miss even a single one it fucks things up.
- For general use, we have the EntityField system.  That, incidentally, also fixes the circular serialization problem at the same time.
    - This creates an opportunity to update while unboxing, but that's a bit dangerous, because it's a potential state change based on something that's only supposed to read state.
    - There's also a lot of temptation to just flatly assume it's spawned, which can be dangerous if you assume wrong.
    
    Can we brainstorm any alternatives?
    - What if we tried to invert all the references; make it so the refered-to items tracked the references?  that sounds like a huge hassle, but it's leading me toward another idea...
    - What if every entity had a singleton "PointToMe" object associated with it, and we could handle stuff through there?  Hey this is really fucking promising.  Yeah, this is going somewhere.
    - Then at least, you don't have to worry about the timing of the updates; that will all get handled by the object itself.
    - You do still have to do a lot of unboxing.  But I guess maybe we can deal.  Now here's a thought...we could call it a ListenedEntityPointer or something, to remind us that we should be listening to it.
    - Now...yeah...you do still kind of have that same problem...egghh...well...maybe we can make this a multi-part thing.  The ideal thing would be that we can check its nullity really fast...
    - Well okay...we can make the EntityField thing into singletons really easily, and that at least takes the weird update timing thing off the table.
    - Now what happens if we call it a ListenerHandleEntityReference instead of an EntityField?  What does that imply our responsibilities are?  We sign up on the listener list for Despawn events?  Are those the only dangerous ones?  I think so.
    - So...let's think about some kind of three-way handling here.  The only way you could populate the Pointer field is to call upon a third object, which would take that pointing field and the target as its arguments.  Then you would have
    the ability, via reflection, to automagically nullify the field via reflection whenever the target changes.  That's very much against how this is supposed to work but there you ware.
    - But...you can kinda sorta reach the same kinda situation by calling it a ListenerHandledEntityField...and handling it.  So...is it *just* despawning we're worried about?